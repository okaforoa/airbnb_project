{"version":3,"file":"static/chunks/76.a51d7b9e20feca23.js","mappings":"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","sources":["webpack://_N_E/../../node_modules/lodash/memoize.js","webpack://_N_E/../ui-core/src/app/FeatureFlags.oss.tsx","webpack://_N_E/../ui-core/src/app/DefaultFeatureFlags.oss.tsx","webpack://_N_E/../ui-core/src/hooks/useStateWithStorage.tsx","webpack://_N_E/../ui-core/src/app/Flags.tsx","webpack://_N_E/../ui-core/src/workers/WorkerThread.oss.ts","webpack://_N_E/../../node_modules/@vx/shape/esm/shapes/link/diagonal/LinkVertical.js","webpack://_N_E/../ui-core/src/util/idb-lru-cache.ts","webpack://_N_E/../ui-core/src/util/weakMapMemoize.ts","webpack://_N_E/../ui-core/src/app/Util.tsx","webpack://_N_E/../ui-core/src/asset-graph/Utils.tsx","webpack://_N_E/../ui-core/src/asset-graph/layout.ts","webpack://_N_E/../ui-core/src/app/titleOfIO.ts","webpack://_N_E/../ui-core/src/graph/layout.ts","webpack://_N_E/../ui-core/src/workers/dagre_layout.worker.ts","webpack://_N_E/webpack/bootstrap","webpack://_N_E/webpack/runtime/chunk loaded","webpack://_N_E/webpack/runtime/compat get default export","webpack://_N_E/webpack/runtime/define property getters","webpack://_N_E/webpack/runtime/ensure chunk","webpack://_N_E/webpack/runtime/get javascript chunk filename","webpack://_N_E/webpack/runtime/get mini-css chunk filename","webpack://_N_E/webpack/runtime/global","webpack://_N_E/webpack/runtime/hasOwnProperty shorthand","webpack://_N_E/webpack/runtime/node module decorator","webpack://_N_E/webpack/runtime/trusted types policy","webpack://_N_E/webpack/runtime/trusted types script url","webpack://_N_E/webpack/runtime/publicPath","webpack://_N_E/webpack/runtime/importScripts chunk loading","webpack://_N_E/webpack/runtime/startup chunk dependencies","webpack://_N_E/webpack/before-startup","webpack://_N_E/webpack/startup","webpack://_N_E/webpack/after-startup"],"sourcesContent":["var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","export enum FeatureFlag {\n  flagDebugConsoleLogging = 'flagDebugConsoleLogging',\n  flagDisableWebsockets = 'flagDisableWebsockets',\n  flagSidebarResources = 'flagSidebarResources',\n  flagDisableAutoLoadDefaults = 'flagDisableAutoLoadDefaults',\n  flagSelectionSyntax = 'flagSelectionSyntax-always-on',\n  flagAssetSelectionWorker = 'flagAssetSelectionWorker',\n  flagAssetNodeFacets = 'flagAssetNodeFacets',\n  flagUseNewObserveUIs = 'flagUseNewObserveUIs',\n  flagMarketplace = 'flagMarketplace',\n  flagDocsInApp = 'flagDocsInApp',\n\n  // Flags for tests\n  __TestFlagDefaultNone = '__TestFlagDefaultNone',\n  __TestFlagDefaultTrue = '__TestFlagDefaultTrue',\n  __TestFlagDefaultFalse = '__TestFlagDefaultFalse',\n}\n","import {FeatureFlag} from 'shared/app/FeatureFlags.oss';\n\n/**\n * Default values for feature flags when they are unset.\n */\nexport const DEFAULT_FEATURE_FLAG_VALUES: Partial<Record<FeatureFlag, boolean>> = {\n  [FeatureFlag.flagAssetSelectionWorker]: true,\n  [FeatureFlag.flagSelectionSyntax]: true,\n\n  // Flags for tests\n  [FeatureFlag.__TestFlagDefaultTrue]: true,\n  [FeatureFlag.__TestFlagDefaultFalse]: false,\n};\n","import * as React from 'react';\n\nexport function getJSONForKey(key: string) {\n  let stored = undefined;\n  try {\n    if (typeof window === 'undefined') {\n      stored = self.localStorage.getItem(key);\n    } else {\n      stored = window.localStorage.getItem(key);\n    }\n    if (stored) {\n      return JSON.parse(stored);\n    }\n  } catch {\n    if (typeof stored === 'string') {\n      // With useStateWithStorage, some values like timezone are moving from `UTC` to `\"UTC\"`\n      // in LocalStorage. To read the old values, pass through raw string values. We can\n      // remove this a few months after 0.14.1 is released.\n      return stored;\n    }\n    return undefined;\n  }\n}\n\nconst DID_WRITE_LOCALSTORAGE = '';\n\nexport function useStateWithStorage<T>(key: string, validate: (json: any) => T) {\n  const [version, setVersion] = React.useState(0);\n\n  const validateRef = React.useRef(validate);\n  validateRef.current = validate;\n\n  const listener = React.useCallback(\n    (event: Event) => {\n      if (event instanceof CustomEvent && event.detail === key) {\n        setVersion((v) => v + 1);\n      }\n    },\n    [key],\n  );\n\n  React.useEffect(() => {\n    document.addEventListener(DID_WRITE_LOCALSTORAGE, listener);\n    return () => document.removeEventListener(DID_WRITE_LOCALSTORAGE, listener);\n  }, [listener]);\n\n  // Note: This hook doesn't keep the loaded data in state -- instead it uses a version bit and\n  // a ref to load the value from localStorage when the `key` changes or when the `version` changes.\n  // This allows us to immediately return the saved value for `key` in the same render.\n\n  const state = React.useMemo(() => {\n    return validate(getJSONForKey(key));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [validate, key, version]);\n\n  const setStateInner = React.useCallback(\n    (next: T | undefined) => {\n      if (next === undefined) {\n        window.localStorage.removeItem(key);\n      } else {\n        window.localStorage.setItem(key, JSON.stringify(next));\n      }\n      document.removeEventListener(DID_WRITE_LOCALSTORAGE, listener);\n      document.dispatchEvent(new CustomEvent(DID_WRITE_LOCALSTORAGE, {detail: key}));\n      document.addEventListener(DID_WRITE_LOCALSTORAGE, listener);\n\n      setVersion((v) => v + 1);\n\n      return next;\n    },\n    [key, listener],\n  );\n\n  const setState = React.useCallback(\n    (input: React.SetStateAction<T>) => {\n      const next =\n        input instanceof Function ? input(validateRef.current(getJSONForKey(key))) : input;\n      setStateInner(next);\n    },\n    [key, setStateInner],\n  );\n\n  const clearState = React.useCallback(() => {\n    setStateInner(undefined);\n  }, [setStateInner]);\n\n  return [state, setState, clearState] as const;\n}\n","import {useEffect, useState} from 'react';\nimport {DEFAULT_FEATURE_FLAG_VALUES} from 'shared/app/DefaultFeatureFlags.oss';\nimport {FeatureFlag} from 'shared/app/FeatureFlags.oss';\n\nimport {getJSONForKey} from '../hooks/useStateWithStorage';\n\nexport const DAGSTER_FLAGS_KEY = 'DAGSTER_FLAGS';\n\nexport const WEB_WORKER_FEATURE_FLAGS_KEY = '__featureFlags';\n\n/**\n * Type representing the mapping of feature flags to their boolean states.\n */\ntype FeatureFlagMap = Partial<Record<FeatureFlag, boolean>>;\n\n/**\n * In-memory cache for feature flags, excludes default values.\n */\nlet currentFeatureFlags: FeatureFlagMap = {};\n\n/**\n * Initialize the in-memory cache by loading from localStorage and handling migration.\n */\nconst initializeFeatureFlags = () => {\n  let flags = getJSONForKey(DAGSTER_FLAGS_KEY);\n\n  // Handle backward compatibility by migrating array to object\n  if (Array.isArray(flags)) {\n    const migratedFlags: FeatureFlagMap = {};\n    flags.forEach((flag: FeatureFlag) => {\n      migratedFlags[flag] = true;\n    });\n    setFeatureFlagsInternal(migratedFlags);\n    flags = migratedFlags;\n  }\n\n  currentFeatureFlags = flags || {};\n};\n\n/**\n * Internal function to set feature flags without broadcasting.\n * Used during initialization and migration and by web-workers.\n */\nexport const setFeatureFlagsInternal = (flags: FeatureFlagMap) => {\n  if (typeof flags !== 'object' || Array.isArray(flags)) {\n    throw new Error('flags must be an object mapping FeatureFlag to boolean values');\n  }\n  currentFeatureFlags = flags;\n  if (typeof localStorage !== 'undefined') {\n    localStorage.setItem(DAGSTER_FLAGS_KEY, JSON.stringify(flags));\n  }\n};\n\n// Initialize the BroadcastChannel\nconst featureFlagsChannel = new BroadcastChannel('feature-flags');\n\n// Initialize feature flags on module load\ninitializeFeatureFlags();\n\nexport const getFeatureFlagsWithoutDefaultValues = (): FeatureFlagMap => {\n  return currentFeatureFlags;\n};\n\nexport const getFeatureFlagDefaults = (): FeatureFlagMap => {\n  return DEFAULT_FEATURE_FLAG_VALUES;\n};\n\nexport const getFeatureFlagsWithDefaults = (): FeatureFlagMap => {\n  return {...DEFAULT_FEATURE_FLAG_VALUES, ...currentFeatureFlags};\n};\n\n/**\n * Function to check if a specific feature flag is enabled.\n * Falls back to default values if the flag is unset.\n */\nexport const featureEnabled = (flag: FeatureFlag): boolean => {\n  if (flag in currentFeatureFlags) {\n    return currentFeatureFlags[flag]!;\n  }\n\n  // Return default value if flag is unset\n  return DEFAULT_FEATURE_FLAG_VALUES[flag] ?? false;\n};\n\n/**\n * Hook to access feature flags within React components.\n * Returns a flag map with resolved values (considering defaults).\n */\nexport const useFeatureFlags = (): Readonly<Record<FeatureFlag, boolean>> => {\n  const [flags, setFlags] = useState<Record<FeatureFlag, boolean>>(() => {\n    const allFlags: Partial<Record<FeatureFlag, boolean>> = {};\n\n    for (const flag in FeatureFlag) {\n      const key = flag as FeatureFlag;\n      if (key in currentFeatureFlags) {\n        allFlags[key] = currentFeatureFlags[key];\n      } else {\n        allFlags[key] = DEFAULT_FEATURE_FLAG_VALUES[key] ?? false;\n      }\n    }\n    return allFlags as Record<FeatureFlag, boolean>;\n  });\n\n  useEffect(() => {\n    const handleFlagsChange = () => {\n      const allFlags: Partial<Record<FeatureFlag, boolean>> = {};\n\n      for (const flag in FeatureFlag) {\n        const key = flag as FeatureFlag;\n        if (key in currentFeatureFlags) {\n          allFlags[key] = currentFeatureFlags[key];\n        } else {\n          allFlags[key] = DEFAULT_FEATURE_FLAG_VALUES[key] ?? false;\n        }\n      }\n      setFlags(allFlags as Record<FeatureFlag, boolean>);\n    };\n\n    // Listen for messages from the BroadcastChannel\n    featureFlagsChannel.addEventListener('message', handleFlagsChange);\n\n    return () => {\n      featureFlagsChannel.removeEventListener('message', handleFlagsChange);\n    };\n  }, []);\n\n  return flags;\n};\n\n/**\n * Function to update feature flags.\n * Updates the in-memory cache, persists to localStorage, and broadcasts the change.\n */\nexport const setFeatureFlags = (flags: FeatureFlagMap) => {\n  setFeatureFlagsInternal(flags);\n  featureFlagsChannel.postMessage('updated');\n};\n\nexport const toggleFeatureFlag = (flag: FeatureFlag) => {\n  const flags = getFeatureFlagsWithDefaults();\n  flags[flag] = !flags[flag];\n  setFeatureFlags(flags);\n  featureFlagsChannel.postMessage('updated');\n};\n","import {WEB_WORKER_FEATURE_FLAGS_KEY, setFeatureFlags} from '../app/Flags';\n\nexport const createWorkerThread = (\n  onMessage: (postMessage: (message: any) => void, data: any) => Promise<void>,\n  onError: (postMessage: (message: any) => void, error: Error, event: MessageEvent) => void,\n) => {\n  self.addEventListener('message', async (event) => {\n    try {\n      if (event.data[WEB_WORKER_FEATURE_FLAGS_KEY]) {\n        setFeatureFlags(event.data[WEB_WORKER_FEATURE_FLAGS_KEY]);\n      } else {\n        await onMessage(self.postMessage, event.data);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        self.postMessage({type: 'error', error: error.message, stack: error.stack});\n      } else {\n        self.postMessage({type: 'error', error: String(error), stack: undefined});\n      }\n      onError(self.postMessage, error as Error, event);\n    }\n  });\n};\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from 'react';\nimport cx from 'classnames';\nimport PropTypes from 'prop-types';\nimport { linkVertical } from 'd3-shape';\nexport function pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n  return function (data) {\n    var link = linkVertical();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\nLinkVertical.propTypes = {\n  innerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),\n  x: PropTypes.func,\n  y: PropTypes.func,\n  source: PropTypes.func,\n  target: PropTypes.func,\n  path: PropTypes.func,\n  className: PropTypes.string,\n  children: PropTypes.func,\n  data: PropTypes.any\n};\nexport default function LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === void 0 ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === void 0 ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === void 0 ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === void 0 ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      children = _ref2.children,\n      restProps = _objectWithoutPropertiesLoose(_ref2, [\"className\", \"innerRef\", \"data\", \"path\", \"x\", \"y\", \"source\", \"target\", \"children\"]);\n\n  var pathGen = path || pathVerticalDiagonal({\n    source: source,\n    target: target,\n    x: x,\n    y: y\n  });\n  if (children) return children({\n    path: path\n  });\n  return React.createElement(\"path\", _extends({\n    ref: innerRef,\n    className: cx('vx-link vx-link-vertical-diagonal', className),\n    d: pathGen(data)\n  }, restProps));\n}","import debounce from 'lodash/debounce';\n\nimport {LRUCache} from './lru-cache';\n\ninterface CacheOptions {\n  dbName: string;\n  dbVersion?: number;\n  maxCount: number;\n}\n\nclass IDBError extends Error {\n  constructor(\n    message: string,\n    public originalError?: unknown,\n  ) {\n    super(message);\n    this.name = 'IDBError';\n  }\n}\n\n/**\n * A cache that uses IndexedDB to store and retrieve an in-memory LRUCache.\n */\nclass IDBLRUCache<T> {\n  private dbName: string;\n  private maxCount: number;\n  private dbPromise: Promise<IDBDatabase> | undefined;\n  private isDbOpen = false;\n  private lruCache: LRUCache<T>;\n  private dbVersion?: number;\n\n  constructor({dbName, dbVersion, maxCount}: CacheOptions) {\n    this.dbName = `idb-lru-cache-v1-${dbName}`;\n    this.maxCount = maxCount;\n    this.lruCache = new LRUCache<T>(maxCount);\n    this.dbPromise = this.initDB();\n    this.dbVersion = dbVersion;\n  }\n\n  private async initDB(): Promise<IDBDatabase> {\n    const request = indexedDB.open(this.dbName, this.dbVersion);\n\n    return new Promise((resolve, reject) => {\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains('cache')) {\n          db.createObjectStore('cache');\n        }\n      };\n      request.onsuccess = async (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        this.isDbOpen = true;\n\n        // Load the entire cache from IndexedDB\n        const tx = db.transaction('cache', 'readonly');\n        const store = tx.objectStore('cache');\n        const request = store.get('lru-cache');\n\n        await new Promise<void>((resolve, reject) => {\n          request.onsuccess = () => {\n            if (request.result) {\n              this.lruCache = LRUCache.fromJSON(request.result, this.maxCount);\n            }\n            resolve();\n          };\n          request.onerror = () => {\n            reject(new IDBError('Failed to load cache', request.error));\n          };\n        });\n\n        resolve(db);\n      };\n      request.onerror = (event) => {\n        this.isDbOpen = false;\n        reject(new IDBError('Failed to open database', (event.target as IDBOpenDBRequest).error));\n      };\n      request.onblocked = () => {\n        this.isDbOpen = false;\n        reject(new IDBError('Database is blocked'));\n      };\n    });\n  }\n\n  private async withDB<T>(operation: (db: IDBDatabase) => Promise<T>): Promise<T> {\n    try {\n      if (!this.dbPromise) {\n        this.dbPromise = this.initDB();\n      }\n      const db = await this.dbPromise;\n      if (!this.isDbOpen) {\n        throw new IDBError('Database is not open', this.dbName);\n      }\n      return await operation(db);\n    } catch (error) {\n      if (error instanceof IDBError) {\n        throw error;\n      }\n      throw new IDBError('Database operation failed', error);\n    }\n  }\n\n  private syncToDB = debounce(async (): Promise<void> => {\n    return this.withDB(async (db) => {\n      const transaction = db.transaction('cache', 'readwrite');\n      const store = transaction.objectStore('cache');\n\n      await new Promise((resolve, reject) => {\n        const putRequest = store.put(this.lruCache.toJSON(), 'lru-cache');\n        putRequest.onsuccess = () => resolve(void 0);\n        putRequest.onerror = () => reject(new IDBError('Failed to sync cache', putRequest.error));\n      });\n    });\n  }, 1000);\n\n  async set(key: string, value: T): Promise<void> {\n    return this.withDB(async () => {\n      this.lruCache.put(key, value);\n      this.syncToDB();\n    });\n  }\n\n  async get(key: string): Promise<{value: T} | undefined> {\n    return this.withDB(async () => {\n      const value = this.lruCache.get(key);\n      return value !== undefined ? {value} : undefined;\n    });\n  }\n\n  async has(key: string): Promise<boolean> {\n    return this.withDB(async () => {\n      return this.lruCache.get(key) !== undefined;\n    });\n  }\n\n  async delete(key: string): Promise<void> {\n    return this.withDB(async () => {\n      this.lruCache.put(key, undefined as any); // Using put to trigger LRU eviction\n      this.syncToDB();\n    });\n  }\n\n  async clear(): Promise<void> {\n    return this.withDB(async () => {\n      this.lruCache = new LRUCache<T>(this.maxCount);\n      this.syncToDB();\n    });\n  }\n\n  async close(): Promise<void> {\n    await this.syncToDB.flush();\n    await this.withDB(async (db) => {\n      this.isDbOpen = false;\n      delete this.dbPromise;\n      db.close();\n    });\n  }\n}\n\nexport function cache<T>(options: CacheOptions): IDBLRUCache<T> {\n  return new IDBLRUCache<T>(options);\n}\n","import LRU from 'lru-cache';\n\ntype AnyFunction = (...args: any[]) => any;\n\ninterface WeakMapMemoizeOptions {\n  maxEntries?: number; // Optional limit for cached entries\n  ttl?: number; // Time-To-Live in seconds\n}\n\ninterface CacheNode {\n  map: Map<any, CacheNode>;\n  weakMap: WeakMap<object, CacheNode>;\n  result?: any;\n  parent?: CacheNode;\n  parentKey?: any;\n  lruKey?: any; // Reference to the key in the LRU cache\n  childCount: number; // Number of child nodes\n  timeoutId?: ReturnType<typeof setTimeout>; // Timer for TTL eviction\n}\n\n/**\n * Determines if a value is a non-null object or function.\n * @param value - The value to check.\n * @returns True if the value is a non-null object or function, false otherwise.\n */\nfunction isObject(value: any): value is object {\n  return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\n/**\n * Recursively deletes parent nodes if their childCount reaches zero.\n * @param cacheNode - The cache node to start deletion from.\n */\nfunction recursivelyDeleteParent(cacheNode: CacheNode) {\n  if (cacheNode.parent && cacheNode.parentKey !== undefined) {\n    const parent = cacheNode.parent;\n    const parentKey = cacheNode.parentKey;\n\n    // Remove the current cacheNode from its parent\n    if (isObject(parentKey)) {\n      parent.weakMap.delete(parentKey);\n    } else {\n      parent.map.delete(parentKey);\n    }\n\n    // Clear the TTL timer if set\n    if (cacheNode.timeoutId) {\n      clearTimeout(cacheNode.timeoutId);\n    }\n\n    // Decrement the parent's child count\n    parent.childCount--;\n\n    // If the parent's childCount reaches zero and it's not the root, recurse\n    if (parent.childCount === 0 && parent.parent) {\n      recursivelyDeleteParent(parent);\n    }\n  }\n}\n\n/**\n * Memoizes a function using nested Maps and WeakMaps based on the arguments.\n * Optionally limits the number of cached entries using an LRU cache and sets TTL for cache entries.\n * Handles both primitive and object arguments efficiently.\n * @param fn - The function to memoize.\n * @param options - Optional settings for memoization.\n * @returns A memoized version of the function.\n */\nexport function weakMapMemoize<T extends AnyFunction>(fn: T, options?: WeakMapMemoizeOptions): T {\n  const {maxEntries, ttl} = options || {};\n\n  // Initialize the root cache node\n  const cacheRoot: CacheNode = {\n    map: new Map(),\n    weakMap: new WeakMap(),\n    childCount: 0,\n  };\n\n  // Initialize LRU Cache if maxEntries is specified\n  let lruCache: LRU<any, CacheNode> | null = null;\n\n  if (maxEntries) {\n    lruCache = new LRU<any, CacheNode>({\n      max: maxEntries,\n      dispose: (_key, cacheNode) => {\n        // Remove the cached result\n        delete cacheNode.result;\n\n        // Clear the TTL timer if set\n        if (cacheNode.timeoutId) {\n          clearTimeout(cacheNode.timeoutId);\n        }\n\n        // If there are no child nodes, proceed to remove this node from its parent\n        if (cacheNode.childCount === 0 && cacheNode.parent && cacheNode.parentKey !== undefined) {\n          recursivelyDeleteParent(cacheNode);\n        }\n      },\n      noDisposeOnSet: false, // Ensure dispose is called on eviction\n    });\n  }\n\n  return function memoizedFunction(...args: any[]) {\n    let currentCache = cacheRoot;\n    const path: any[] = [];\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      path.push(arg);\n      const isArgObject = isObject(arg);\n\n      let nextCacheNode: CacheNode | undefined;\n\n      if (isArgObject) {\n        if (!currentCache.weakMap.has(arg)) {\n          const newCacheNode: CacheNode = {\n            map: new Map(),\n            weakMap: new WeakMap(),\n            parent: currentCache,\n            parentKey: arg,\n            childCount: 0,\n          };\n          currentCache.weakMap.set(arg, newCacheNode);\n          currentCache.childCount++;\n        }\n        nextCacheNode = currentCache.weakMap.get(arg);\n      } else {\n        if (!currentCache.map.has(arg)) {\n          const newCacheNode: CacheNode = {\n            map: new Map(),\n            weakMap: new WeakMap(),\n            parent: currentCache,\n            parentKey: arg,\n            childCount: 0,\n          };\n          currentCache.map.set(arg, newCacheNode);\n          currentCache.childCount++;\n        }\n        nextCacheNode = currentCache.map.get(arg);\n      }\n\n      currentCache = nextCacheNode!;\n    }\n\n    // After traversing all arguments, check if the result is cached\n    if ('result' in currentCache) {\n      // If using LRU Cache, update its usage\n      if (lruCache && currentCache.lruKey) {\n        lruCache.get(currentCache.lruKey); // This updates the recentness\n      }\n      return currentCache.result;\n    }\n\n    // Compute the result\n    const result = fn(...args);\n\n    // Cache the result\n    currentCache.result = result;\n\n    // If TTL is specified, set a timeout to evict the cache entry\n    if (ttl) {\n      currentCache.timeoutId = setTimeout(() => {\n        // Remove the result\n        delete currentCache.result;\n\n        // Remove from LRU if applicable\n        if (lruCache && currentCache.lruKey) {\n          lruCache.del(currentCache.lruKey);\n        }\n\n        // Recursively delete parent nodes if necessary\n        if (\n          currentCache.childCount === 0 &&\n          currentCache.parent &&\n          currentCache.parentKey !== undefined\n        ) {\n          recursivelyDeleteParent(currentCache);\n        }\n      }, ttl * 1000); // Convert seconds to milliseconds\n    }\n\n    // If LRU cache is enabled, manage the cache entries\n    if (lruCache && !currentCache.lruKey) {\n      const cacheEntryKey = Symbol();\n      currentCache.lruKey = cacheEntryKey; // Associate the cache node with the LRU key\n      lruCache.set(cacheEntryKey, currentCache);\n    }\n\n    return result;\n  } as T;\n}\n","import memoize from 'lodash/memoize';\nimport LRU from 'lru-cache';\n\nimport {timeByParts} from './timeByParts';\nimport {cache} from '../util/idb-lru-cache';\nimport {weakMapMemoize} from '../util/weakMapMemoize';\n\nfunction twoDigit(v: number) {\n  return `${v < 10 ? '0' : ''}${v}`;\n}\n\nfunction indexesOf(string: string, search: RegExp | string) {\n  const indexes: number[] = [];\n  const regexp = new RegExp(search, 'g');\n  let match = null;\n  while ((match = regexp.exec(string))) {\n    indexes.push(match.index);\n  }\n  return indexes;\n}\n\nexport const withMiddleTruncation = (text: string, options: {maxLength: number}) => {\n  const overflowLength = text.length - options.maxLength;\n  if (overflowLength <= 0) {\n    // No truncation is necessary\n    return text;\n  }\n  if (options.maxLength <= 10) {\n    // Middle truncation to this few characters (eg: abc…ef) is kind of silly\n    // and just using abcde… looks better.\n    return text.substring(0, options.maxLength - 1) + '…';\n  }\n\n  // Find all the breakpoints in the string\n  //   \"my_great_long_solid_name\"\n  //     ˄     ˄    ˄     ˄\n  const breakpoints = text.includes('__') ? indexesOf(text, /__/g) : indexesOf(text, /[_>\\.-]/g);\n\n  // Given no breakpoints, slice out the middle of the string. Adding\n  // the overflowLength here gives us the END point of the truncated region.\n  //\n  //   \"abc(defg)hijk\"\n  //            ˄\n  let breakpoint = Math.floor((text.length + overflowLength) / 2);\n\n  // Find the first breakpoint that exists AFTER enough characters that we could show\n  // at least three prefix letters after cutting out overflowLength.\n  const firstUsableIdx = breakpoints.findIndex((bp) => bp > overflowLength + 3);\n\n  if (firstUsableIdx !== -1) {\n    // If we found a usable breakpoint, see if we could instead choose the middle\n    // breakpoint which would give us more prefix. All else equal,\n    // \"my_great_l…_name\" looks better than \"my_g…_solid_name\"\n    const middleIdx = Math.floor(breakpoints.length / 2);\n    const breakpointAtIndex = breakpoints[Math.max(firstUsableIdx, middleIdx)];\n    if (breakpointAtIndex !== undefined) {\n      breakpoint = breakpointAtIndex;\n    }\n  }\n\n  const result = [\n    text.substring(0, breakpoint - (overflowLength + 1)),\n    text.substring(breakpoint),\n  ].join('…');\n\n  return result;\n};\n\nconst msecFormatter = memoize((locale: string) => {\n  return new Intl.NumberFormat(locale, {\n    minimumFractionDigits: 3,\n    maximumFractionDigits: 3,\n  });\n});\n\n/**\n * Return an i18n-formatted millisecond in seconds as a decimal, with no leading zero.\n */\nconst formatMsecMantissa = (msec: number) =>\n  msecFormatter(navigator.language)\n    .format(msec / 1000)\n    .slice(-4);\n\n/**\n * Format the time without milliseconds, rounding to :01 for non-zero value within (-1, 1)\n */\nexport const formatElapsedTimeWithoutMsec = (msec: number) => {\n  const {hours, minutes, seconds} = timeByParts(msec);\n  const negative = msec < 0;\n  const roundedSeconds = msec !== 0 && msec < 1000 && msec > -1000 ? 1 : seconds;\n  return `${negative ? '-' : ''}${hours}:${twoDigit(minutes)}:${twoDigit(roundedSeconds)}`;\n};\n\nexport const formatElapsedTimeWithMsec = (msec: number) => {\n  const {hours, minutes, seconds, milliseconds} = timeByParts(msec);\n\n  const negative = msec < 0;\n  const sign = negative ? '-' : '';\n  const hourStr = hours > 0 ? `${hours}:` : '';\n  const minuteStr = hours > 0 ? `${twoDigit(minutes)}:` : minutes > 0 ? `${minutes}:` : '';\n  const secStr = hours > 0 || minutes > 0 ? `${twoDigit(seconds)}` : `${seconds}`;\n  const mantissa = formatMsecMantissa(milliseconds);\n\n  return `${sign}${hourStr}${minuteStr}${secStr}${mantissa}`;\n};\n\nexport function breakOnUnderscores(str: string) {\n  return str.replace(/_/g, '_\\u200b');\n}\n\nexport function patchCopyToRemoveZeroWidthUnderscores() {\n  document.addEventListener('copy', (event) => {\n    if (!event.clipboardData) {\n      // afaik this is always defined, but the TS field is optional\n      return;\n    }\n\n    // Note: This returns the text of the current selection if DOM\n    // nodes are selected. If the selection on the page is text within\n    // codemirror or an input or textarea, this returns \"\" and we fall\n    // through to the default pasteboard content.\n    const text = (window.getSelection() || '').toString().replace(/_\\u200b/g, '_');\n\n    if (text.length) {\n      event.preventDefault();\n      event.clipboardData.setData('Text', text);\n    }\n  });\n}\n\nexport function asyncMemoize<T, R, U extends (arg: T, ...rest: any[]) => PromiseLike<R>>(\n  fn: U,\n  hashFn?: (arg: T, ...rest: any[]) => any,\n  hashSize?: number,\n): U {\n  const cache = new LRU<any, R>(hashSize || 50);\n  return (async (arg: T, ...rest: any[]) => {\n    const key = hashFn ? hashFn(arg, ...rest) : arg;\n    if (cache.has(key)) {\n      return Promise.resolve(cache.get(key) as R);\n    }\n    const r = (await fn(arg, ...rest)) as R;\n    cache.set(key, r);\n    return r;\n  }) as any;\n}\n\nexport function indexedDBAsyncMemoize<R, U extends (...args: any[]) => Promise<R>>(\n  fn: U,\n  hashFn?: (...args: Parameters<U>) => any,\n  key?: string,\n): U & {\n  isCached: (...args: Parameters<U>) => Promise<boolean>;\n} {\n  let lru: ReturnType<typeof cache<R>> | undefined;\n  try {\n    lru = cache<R>({\n      dbName: `indexDBAsyncMemoizeDB${key}`,\n      maxCount: 50,\n    });\n  } catch {}\n\n  const hashToPromise: Record<string, Promise<R>> = {};\n\n  const genHashKey = weakMapMemoize(async (...args: Parameters<U>) => {\n    const hash = hashFn ? hashFn(...args) : args;\n\n    const encoder = new TextEncoder();\n    // Crypto.subtle isn't defined in insecure contexts... fallback to using the full string as a key\n    // https://stackoverflow.com/questions/46468104/how-to-use-subtlecrypto-in-chrome-window-crypto-subtle-is-undefined\n    if (crypto.subtle?.digest) {\n      const data = encoder.encode(hash.toString());\n      const hashBuffer = await crypto.subtle.digest('SHA-1', data);\n      const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n      return hashArray.map((b) => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string\n    }\n    return hash.toString();\n  });\n\n  const ret = (async (...args: Parameters<U>) => {\n    return new Promise<R>(async (resolve, reject) => {\n      const hashKey = await genHashKey(...args);\n      if (lru && (await lru.has(hashKey))) {\n        const entry = await lru.get(hashKey);\n        const value = entry?.value;\n        if (value) {\n          resolve(value);\n        } else {\n          reject(new Error('No value found'));\n        }\n        return;\n      } else if (!hashToPromise[hashKey]) {\n        hashToPromise[hashKey] = new Promise(async (res) => {\n          const result = await fn(...args);\n          // Resolve the promise before storing the result in IndexedDB\n          res(result);\n          if (lru) {\n            await lru.set(hashKey, result);\n            delete hashToPromise[hashKey];\n          }\n        });\n      }\n      resolve(await hashToPromise[hashKey]!);\n    });\n  }) as any;\n  ret.isCached = async (...args: Parameters<U>) => {\n    const hashKey = await genHashKey(...args);\n    if (!lru) {\n      return false;\n    }\n    return await lru.has(hashKey);\n  };\n  return ret;\n}\n\nexport function assertUnreachable(value: never): never {\n  throw new Error(`Didn't expect to get here with value: ${JSON.stringify(value)}`);\n}\n\nexport function colorHash(str: string) {\n  let seed = 0;\n  for (let i = 0; i < str.length; i++) {\n    seed = ((seed << 5) - seed + str.charCodeAt(i)) | 0;\n  }\n\n  const random255 = (x: number) => {\n    const value = Math.sin(x) * 10000;\n    return 255 * (value - Math.floor(value));\n  };\n\n  return `rgb(${random255(seed++)}, ${random255(seed++)}, ${random255(seed++)})`;\n}\n\n// Useful for generating predicates to retain type information when\n// find/filtering GraphQL results. Example:\n//\n// const textMetadata = metadataEntries.filter(gqlTypePredicate('TextMetadataEntry'));\n//\n// `textMetadata` will be of type `TextMetadataEntry[]`.\nexport const gqlTypePredicate =\n  <T extends string>(typename: T) =>\n  <N extends {__typename: string}>(node: N): node is Extract<N, {__typename: T}> => {\n    return node.__typename === typename;\n  };\n\nexport const COMMON_COLLATOR = new Intl.Collator(navigator.language, {sensitivity: 'base'});\n","import {pathHorizontalDiagonal, pathVerticalDiagonal} from '@vx/shape';\nimport memoize from 'lodash/memoize';\n\nimport {AssetNodeKeyFragment} from './types/AssetNode.types';\nimport {AssetNodeForGraphQueryFragment} from './types/useAssetGraphData.types';\nimport {COMMON_COLLATOR} from '../app/Util';\nimport {\n  AssetCheckLiveFragment,\n  AssetLatestInfoFragment,\n  AssetLatestInfoRunFragment,\n  AssetNodeLiveFragment,\n  AssetNodeLiveFreshnessInfoFragment,\n  AssetNodeLiveMaterializationFragment,\n  AssetNodeLiveObservationFragment,\n} from '../asset-data/types/AssetBaseDataProvider.types';\nimport {AssetStaleDataFragment} from '../asset-data/types/AssetStaleStatusDataProvider.types';\nimport {RunStatus} from '../graphql/types';\n\nexport enum AssetGraphViewType {\n  GLOBAL = 'global',\n  JOB = 'job',\n  GROUP = 'group',\n  CATALOG = 'catalog',\n}\n\n/**\n * IMPORTANT: This file is used by the WebWorker so make sure we don't indirectly import React or anything that relies on window/document\n */\n\n/**\n * IMPORTANT: This file is used by the WebWorker so make sure we don't indirectly import React or anything that relies on window/document\n */\n\ntype AssetNode = AssetNodeForGraphQueryFragment;\ntype AssetKey = AssetNodeKeyFragment;\ntype AssetLiveNode = AssetNodeLiveFragment & {\n  freshnessInfo: AssetNodeLiveFreshnessInfoFragment | null | undefined;\n};\ntype AssetLatestInfo = AssetLatestInfoFragment;\n\nexport const __ASSET_JOB_PREFIX = '__ASSET_JOB';\nexport const __ANONYMOUS_ASSET_JOB_PREFIX = '__anonymous_asset_job';\n\nexport function isHiddenAssetGroupJob(jobName: string) {\n  return jobName.startsWith(__ASSET_JOB_PREFIX) || jobName.startsWith(__ANONYMOUS_ASSET_JOB_PREFIX);\n}\n\n// IMPORTANT: We use this, rather than AssetNode.id throughout this file because\n// the GraphQL interface exposes dependencyKeys, not dependencyIds. We also need\n// ways to \"build\" GraphId's locally, they can't always be server-provided.\n//\n// This value is NOT the same as AssetNode.id values provided by the server,\n// because JSON.stringify's whitespace behavior is different than Python's.\n//\nexport type GraphId = string;\nexport const toGraphId = (key: {path: string[]}): GraphId => JSON.stringify(key.path);\nexport const fromGraphId = (graphId: GraphId): AssetNodeKeyFragment => ({\n  path: JSON.parse(graphId),\n  __typename: 'AssetKey',\n});\n\nexport interface GraphNode {\n  id: GraphId;\n  assetKey: AssetKey;\n  definition: AssetNode;\n}\n\nexport interface GraphData {\n  nodes: {[assetId: GraphId]: GraphNode};\n  downstream: {[assetId: GraphId]: {[childAssetId: GraphId]: boolean}};\n  upstream: {[assetId: GraphId]: {[parentAssetId: GraphId]: boolean}};\n  expandedGroups?: string[];\n}\n\nexport const buildGraphData = (assetNodes: AssetNode[]) => {\n  const data: GraphData = {\n    nodes: {},\n    downstream: {},\n    upstream: {},\n  };\n\n  const addEdge = (upstreamGraphId: string, downstreamGraphId: string) => {\n    if (upstreamGraphId === downstreamGraphId) {\n      // Skip add edges for self-dependencies (eg: assets relying on older partitions of themselves)\n      return;\n    }\n    data.downstream[upstreamGraphId] = {\n      ...(data.downstream[upstreamGraphId] || {}),\n      [downstreamGraphId]: true,\n    };\n    data.upstream[downstreamGraphId] = {\n      ...(data.upstream[downstreamGraphId] || {}),\n      [upstreamGraphId]: true,\n    };\n  };\n\n  assetNodes.forEach((definition: AssetNode) => {\n    const id = toGraphId(definition.assetKey);\n    definition.dependencyKeys.forEach((key) => {\n      addEdge(toGraphId(key), id);\n    });\n    definition.dependedByKeys.forEach((key) => {\n      addEdge(id, toGraphId(key));\n    });\n\n    data.nodes[id] = {\n      id,\n      assetKey: definition.assetKey,\n      definition,\n    };\n  });\n\n  return data;\n};\n\nexport const nodeDependsOnSelf = (node: GraphNode) => {\n  const id = toGraphId(node.assetKey);\n  return node.definition.dependedByKeys.some((d) => toGraphId(d) === id);\n};\n\nexport const graphHasCycles = (graphData: GraphData) => {\n  const nodes = new Set(Object.keys(graphData.nodes));\n  const search = (stack: string[], node: string): boolean => {\n    if (stack.indexOf(node) !== -1) {\n      return true;\n    }\n    if (nodes.delete(node) === true) {\n      const nextStack = stack.concat(node);\n      return Object.keys(graphData.downstream[node] || {}).some((nextNode) =>\n        search(nextStack, nextNode),\n      );\n    }\n    return false;\n  };\n  let hasCycles = false;\n  while (nodes.size !== 0 && !hasCycles) {\n    hasCycles = search([], nodes.values().next().value!);\n  }\n  return hasCycles;\n};\n\nexport const buildSVGPathHorizontal = pathHorizontalDiagonal({\n  source: (s: any) => s.source,\n  target: (s: any) => s.target,\n  x: (s: any) => s.x,\n  y: (s: any) => s.y,\n});\nexport const buildSVGPathVertical = pathVerticalDiagonal({\n  source: (s: any) => s.source,\n  target: (s: any) => s.target,\n  x: (s: any) => s.x,\n  y: (s: any) => s.y,\n});\n\nexport interface LiveDataForNode {\n  stepKey: string;\n  unstartedRunIds: string[]; // run in progress and step not started\n  inProgressRunIds: string[]; // run in progress and step in progress\n  runWhichFailedToMaterialize: AssetLatestInfoRunFragment | null;\n  lastMaterialization: AssetNodeLiveMaterializationFragment | null;\n  lastMaterializationRunStatus: RunStatus | null; // only available if runWhichFailedToMaterialize is null\n  freshnessInfo: AssetNodeLiveFreshnessInfoFragment | null | undefined;\n  lastObservation: AssetNodeLiveObservationFragment | null;\n  assetChecks: AssetCheckLiveFragment[];\n  partitionStats: {\n    numMaterialized: number;\n    numMaterializing: number;\n    numPartitions: number;\n    numFailed: number;\n  } | null;\n  opNames: string[];\n}\n\nexport type LiveDataForNodeWithStaleData = LiveDataForNode & {\n  staleStatus: AssetStaleDataFragment['staleStatus'];\n  staleCauses: AssetStaleDataFragment['staleCauses'];\n};\n\nexport const MISSING_LIVE_DATA: LiveDataForNodeWithStaleData = {\n  unstartedRunIds: [],\n  inProgressRunIds: [],\n  runWhichFailedToMaterialize: null,\n  freshnessInfo: null,\n  lastMaterialization: null,\n  lastMaterializationRunStatus: null,\n  lastObservation: null,\n  partitionStats: null,\n  staleStatus: null,\n  staleCauses: [],\n  assetChecks: [],\n  opNames: [],\n  stepKey: '',\n};\n\nexport interface LiveData {\n  [assetId: GraphId]: LiveDataForNode;\n}\n\nexport const buildLiveDataForNode = (\n  assetNode: AssetLiveNode,\n  assetLatestInfo?: AssetLatestInfo,\n): LiveDataForNode => {\n  const lastMaterialization = assetNode.assetMaterializations[0] || null;\n  const lastObservation = assetNode.assetObservations[0] || null;\n  const latestRun = assetLatestInfo?.latestRun ? assetLatestInfo.latestRun : null;\n\n  return {\n    lastMaterialization,\n    lastMaterializationRunStatus:\n      latestRun && lastMaterialization?.runId === latestRun.id ? latestRun.status : null,\n    lastObservation,\n    assetChecks:\n      assetNode.assetChecksOrError.__typename === 'AssetChecks'\n        ? assetNode.assetChecksOrError.checks\n        : [],\n    stepKey: stepKeyForAsset(assetNode),\n    freshnessInfo: assetNode.freshnessInfo,\n    inProgressRunIds: assetLatestInfo?.inProgressRunIds || [],\n    unstartedRunIds: assetLatestInfo?.unstartedRunIds || [],\n    partitionStats: assetNode.partitionStats || null,\n    runWhichFailedToMaterialize:\n      latestRun && shouldDisplayRunFailure(latestRun, lastMaterialization) ? latestRun : null,\n    opNames: assetNode.opNames,\n  };\n};\n\nexport function shouldDisplayRunFailure(\n  latestRun: AssetLatestInfoRunFragment,\n  lastMaterialization: AssetNodeLiveMaterializationFragment | null,\n) {\n  if (latestRun.status !== 'FAILURE') {\n    return false; // The run did not fail\n  }\n  if (lastMaterialization) {\n    if (lastMaterialization && lastMaterialization.runId === latestRun.id) {\n      // The run failed, but it successfully emitted the latest materialization event. This\n      // is caused by the run failing in a later step.\n      return false;\n    }\n    if (Number(lastMaterialization.timestamp) > Number(latestRun.endTime) * 1000) {\n      // The latest materialization is NEWER than the latest run. This is caused by the user\n      // reporting a materialization manually.\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function tokenForAssetKey(key: {path: string[]}) {\n  return key.path.join('/');\n}\n\nexport function tokenToAssetKey(token: string) {\n  return {path: token.split('/')};\n}\n\nexport function displayNameForAssetKey(key: {path: string[]}) {\n  return key.path.join(' / ');\n}\n\nexport function sortAssetKeys(a: {path: string[]}, b: {path: string[]}) {\n  return COMMON_COLLATOR.compare(displayNameForAssetKey(a), displayNameForAssetKey(b));\n}\n\nexport function stepKeyForAsset(definition: {opNames: string[]}) {\n  // Used for linking to the run with this step highlighted. We only support highlighting\n  // a single step, so just use the first one.\n  const firstOp = definition.opNames.length ? definition.opNames[0] : null;\n  return firstOp || '';\n}\n\nexport const itemWithAssetKey = (key: {path: string[]}) => {\n  const token = tokenForAssetKey(key);\n  return (asset: {assetKey: {path: string[]}}) => tokenForAssetKey(asset.assetKey) === token;\n};\n\nexport const isGroupId = (str: string) => /^[^@:]+@[^@:]+:.+$/.test(str);\n\nexport const groupIdForNode = (node: GraphNode) =>\n  [\n    node.definition.repository.name,\n    '@',\n    node.definition.repository.location.name,\n    ':',\n    node.definition.groupName,\n  ].join('');\n\n// Inclusive\nexport const getUpstreamNodes = memoize(\n  (assetKey: AssetNodeKeyFragment, graphData: GraphData): AssetNodeKeyFragment[] => {\n    const upstream = Object.keys(graphData.upstream[toGraphId(assetKey)] || {});\n    const currentUpstream = upstream.map((graphId) => fromGraphId(graphId));\n    return [\n      assetKey,\n      ...currentUpstream,\n      ...currentUpstream.map((graphId) => getUpstreamNodes(graphId, graphData)).flat(),\n    ].filter(\n      (key, index, arr) =>\n        // Filter out non uniques\n        arr.findIndex((key2) => JSON.stringify(key2) === JSON.stringify(key)) === index,\n    );\n  },\n  (key, data) => JSON.stringify({key, data}),\n);\n","import * as dagre from 'dagre';\n\nimport {AssetNodeFacet} from './AssetNodeFacets';\nimport {GraphData, GraphId, GraphNode, groupIdForNode, isGroupId} from './Utils';\nimport type {IBounds, IPoint} from '../graph/common';\nimport {ChangeReason} from '../graphql/types';\n\nexport type AssetLayoutDirection = 'vertical' | 'horizontal';\n\nexport interface AssetLayout {\n  id: GraphId;\n  bounds: IBounds; // Overall frame of the box relative to 0,0 on the graph\n}\n\nexport interface GroupLayout {\n  id: GraphId;\n  groupName: string;\n  repositoryName: string;\n  repositoryLocationName: string;\n  bounds: IBounds; // Overall frame of the box relative to 0,0 on the graph\n  expanded: boolean;\n}\nexport type AssetLayoutEdge = {\n  from: IPoint;\n  fromId: string;\n  to: IPoint;\n  toId: string;\n};\n\nexport type AssetGraphLayout = {\n  width: number;\n  height: number;\n  edges: AssetLayoutEdge[];\n  nodes: {[id: string]: AssetLayout};\n  groups: {[name: string]: GroupLayout};\n};\nconst MARGIN = 100;\n\nexport type LayoutAssetGraphConfig = dagre.GraphLabel & {\n  direction: AssetLayoutDirection;\n  /** Pass `auto` to use getAssetNodeDimensions, or a value to give nodes a fixed height */\n  nodeHeight: number | 'auto';\n  /** Our asset groups have \"title bars\" - use these numbers to adjust the bounding boxes.\n   * Note that these adjustments are applied post-dagre layout. For padding > nodesep, you\n   * may need to set \"clusterpaddingtop\", \"clusterpaddingbottom\" so Dagre lays out the boxes\n   * with more spacing.\n   */\n  groupPaddingTop: number;\n  groupPaddingBottom: number;\n  groupRendering: 'if-varied' | 'always';\n\n  /** Supported in Dagre, just not documented. Additional spacing between group nodes */\n  clusterpaddingtop?: number;\n  clusterpaddingbottom?: number;\n  ranker?: 'tight-tree' | 'longest-path' | 'network-simplex';\n};\n\nexport type LayoutAssetGraphOptions = {\n  direction: AssetLayoutDirection;\n  overrides?: Partial<LayoutAssetGraphConfig>;\n  facets?: AssetNodeFacet[] | false;\n};\n\nexport const Config = {\n  horizontal: {\n    ranker: 'tight-tree',\n    direction: 'horizontal',\n    marginx: MARGIN,\n    marginy: MARGIN,\n    ranksep: 60,\n    rankdir: 'LR',\n    edgesep: 90,\n    nodesep: -10,\n    nodeHeight: 'auto' as 'auto' | number,\n    groupPaddingTop: 65,\n    groupPaddingBottom: -4,\n    groupRendering: 'if-varied',\n    clusterpaddingtop: 100,\n  },\n  vertical: {\n    ranker: 'tight-tree',\n    direction: 'horizontal',\n    marginx: MARGIN,\n    marginy: MARGIN,\n    ranksep: 20,\n    rankdir: 'TB',\n    nodesep: 40,\n    edgesep: 10,\n    nodeHeight: 'auto' as 'auto' | number,\n    groupPaddingTop: 55,\n    groupPaddingBottom: -4,\n    groupRendering: 'if-varied',\n  },\n};\n\nexport const layoutAssetGraph = (\n  graphData: GraphData,\n  opts: LayoutAssetGraphOptions,\n): AssetGraphLayout => {\n  try {\n    return layoutAssetGraphImpl(graphData, opts);\n  } catch {\n    try {\n      return layoutAssetGraphImpl(graphData, {\n        ...opts,\n        overrides: {\n          ranker: 'longest-path',\n        },\n      });\n    } catch {\n      return layoutAssetGraphImpl(graphData, {...opts, overrides: {ranker: 'network-simplex'}});\n    }\n  }\n};\n\nexport const layoutAssetGraphImpl = (\n  graphData: GraphData,\n  opts: LayoutAssetGraphOptions,\n): AssetGraphLayout => {\n  const g = new dagre.graphlib.Graph({compound: true});\n  const config = Object.assign({}, Config[opts.direction], opts.overrides || {});\n  const facets = opts.facets ? new Set<AssetNodeFacet>(opts.facets) : false;\n\n  g.setGraph(config);\n  g.setDefaultEdgeLabel(() => ({}));\n\n  // const shouldRender = (node?: GraphNode) => node && node.definition.opNames.length > 0;\n  const shouldRender = (node?: GraphNode) => node;\n  const renderedNodes = Object.values(graphData.nodes).filter(shouldRender);\n  const expandedGroups = graphData.expandedGroups || [];\n  const expandedGroupsSet = new Set(expandedGroups);\n\n  // Identify all the groups\n  const groups: {[id: string]: GroupLayout} = {};\n  for (const node of renderedNodes) {\n    if (node.definition.groupName) {\n      const id = groupIdForNode(node);\n      groups[id] = groups[id] || {\n        id,\n        expanded: expandedGroupsSet.has(id),\n        groupName: node.definition.groupName,\n        repositoryName: node.definition.repository.name,\n        repositoryLocationName: node.definition.repository.location.name,\n        bounds: {x: 0, y: 0, width: 0, height: 0},\n      };\n    }\n  }\n\n  // Add all the group boxes to the graph\n  const groupsPresent =\n    config.groupRendering === 'if-varied' ? Object.keys(groups).length > 1 : true;\n\n  if (groupsPresent) {\n    Object.keys(groups).forEach((groupId) => {\n      if (expandedGroupsSet.has(groupId)) {\n        // sized based on it's children, but \"border\" tells Dagre we want cluster-level\n        // spacing between the node and others. Necessary because our groups have title bars.\n        g.setNode(groupId, {borderType: 'borderRight'});\n      } else {\n        g.setNode(groupId, {width: ASSET_NODE_WIDTH, height: 110});\n      }\n    });\n  }\n\n  // Add all the nodes inside expanded groups to the graph\n  renderedNodes.forEach((node) => {\n    if (!groupsPresent || expandedGroupsSet.has(groupIdForNode(node))) {\n      const label =\n        config.nodeHeight === 'auto'\n          ? facets !== false\n            ? getAssetNodeDimensions2025(facets)\n            : getAssetNodeDimensions(node.definition)\n          : {width: ASSET_NODE_WIDTH, height: config.nodeHeight};\n\n      g.setNode(node.id, label);\n      if (groupsPresent && node.definition.groupName) {\n        g.setParent(node.id, groupIdForNode(node));\n      }\n    }\n  });\n\n  const linksToAssetsOutsideGraphedSet: {[id: string]: true} = {};\n  const groupIdForAssetId = Object.fromEntries(\n    Object.entries(graphData.nodes).map(([id, node]) => [id, groupIdForNode(node)]),\n  );\n\n  // Add the edges to the graph, and accumulate a set of \"foreign nodes\" (for which\n  // we have an inbound/outbound edge, but we don't have the `node` in the graphData).\n  Object.entries(graphData.downstream).forEach(([upstreamId, graphDataDownstream]) => {\n    const downstreamIds = Object.keys(graphDataDownstream);\n    downstreamIds.forEach((downstreamId) => {\n      if (\n        !shouldRender(graphData.nodes[downstreamId]) &&\n        !shouldRender(graphData.nodes[upstreamId])\n      ) {\n        return;\n      }\n      let v = upstreamId;\n      let w = downstreamId;\n\n      const wGroup = groupIdForAssetId[downstreamId];\n      if (groupsPresent && wGroup && !expandedGroupsSet.has(wGroup)) {\n        w = wGroup;\n      }\n      const vGroup = groupIdForAssetId[upstreamId];\n      if (groupsPresent && vGroup && !expandedGroupsSet.has(vGroup)) {\n        v = vGroup;\n      }\n      if (v === w) {\n        return;\n      }\n\n      g.setEdge({v, w}, {weight: 1});\n\n      if (!shouldRender(graphData.nodes[downstreamId])) {\n        linksToAssetsOutsideGraphedSet[downstreamId] = true;\n      } else if (!shouldRender(graphData.nodes[upstreamId])) {\n        linksToAssetsOutsideGraphedSet[upstreamId] = true;\n      }\n    });\n  });\n\n  // Add all the link nodes to the graph\n  Object.keys(linksToAssetsOutsideGraphedSet).forEach((id) => {\n    const path = JSON.parse(id);\n    const label = path[path.length - 1] || '';\n    g.setNode(id, getAssetLinkDimensions(label, opts));\n  });\n\n  dagre.layout(g);\n\n  let maxWidth = 1;\n  let maxHeight = 1;\n\n  const nodes: {[id: string]: AssetLayout} = {};\n\n  g.nodes().forEach((id) => {\n    const dagreNode = g.node(id);\n    if (!dagreNode?.x || !dagreNode?.width) {\n      return;\n    }\n    const bounds = {\n      x: dagreNode.x - dagreNode.width / 2,\n      y: dagreNode.y - dagreNode.height / 2,\n      width: dagreNode.width,\n      height: dagreNode.height,\n    };\n    if (!isGroupId(id)) {\n      nodes[id] = {id, bounds};\n    } else if (!expandedGroupsSet.has(id)) {\n      const group = groups[id]!;\n      group.bounds = bounds;\n    }\n\n    maxWidth = Math.max(maxWidth, dagreNode.x + dagreNode.width / 2);\n    maxHeight = Math.max(maxHeight, dagreNode.y + dagreNode.height / 2);\n  });\n\n  // Apply bounds to the groups based on the nodes inside them\n  if (groupsPresent) {\n    for (const node of renderedNodes) {\n      const nodeLayout = nodes[node.id];\n      if (nodeLayout && node.definition.groupName) {\n        const groupId = groupIdForNode(node);\n        const group = groups[groupId]!;\n        group.bounds =\n          group.bounds.width === 0\n            ? nodeLayout.bounds\n            : extendBounds(group.bounds, nodeLayout.bounds);\n      }\n    }\n    for (const group of Object.values(groups)) {\n      if (group.expanded) {\n        group.bounds = padBounds(group.bounds, {\n          x: 15,\n          top: config.groupPaddingTop,\n          bottom: config.groupPaddingBottom,\n        });\n      }\n    }\n  }\n\n  const edges: AssetLayoutEdge[] = [];\n\n  g.edges().forEach((e) => {\n    const v = g.node(e.v);\n    const w = g.node(e.w);\n    if (!v || !w) {\n      return;\n    }\n    const vXInset = !!linksToAssetsOutsideGraphedSet[e.v] ? 16 : 24;\n    const wXInset = !!linksToAssetsOutsideGraphedSet[e.w] ? 16 : 24;\n\n    // Ignore the coordinates from dagre and use the top left + bottom left of the\n    edges.push(\n      opts.direction === 'horizontal'\n        ? {\n            from: {x: v.x + v.width / 2, y: v.y},\n            fromId: e.v,\n            to: {x: w.x - w.width / 2 - 5, y: w.y},\n            toId: e.w,\n          }\n        : {\n            from: {x: v.x - v.width / 2 + vXInset, y: v.y - 30 + v.height / 2},\n            fromId: e.v,\n            to: {x: w.x - w.width / 2 + wXInset, y: w.y + 20 - w.height / 2},\n            toId: e.w,\n          },\n    );\n  });\n\n  return {\n    nodes,\n    edges,\n    width: maxWidth + MARGIN,\n    height: maxHeight + MARGIN,\n    groups: groupsPresent ? groups : {},\n  };\n};\n\nexport const ASSET_LINK_NAME_MAX_LENGTH = 30;\n\nexport const getAssetLinkDimensions = (label: string, opts: LayoutAssetGraphOptions) => {\n  return opts.direction === 'horizontal'\n    ? {width: 32 + 7.1 * Math.min(ASSET_LINK_NAME_MAX_LENGTH, label.length), height: 50}\n    : {width: 106, height: 50};\n};\n\nexport const padBounds = (a: IBounds, padding: {x: number; top: number; bottom: number}) => {\n  return {\n    x: a.x - padding.x,\n    y: a.y - padding.top,\n    width: a.width + padding.x * 2,\n    height: a.height + padding.top + padding.bottom,\n  };\n};\n\nexport const extendBounds = (a: IBounds, b: IBounds) => {\n  const xmin = Math.min(a.x, b.x);\n  const ymin = Math.min(a.y, b.y);\n  const xmax = Math.max(a.x + a.width, b.x + b.width);\n  const ymax = Math.max(a.y + a.height, b.y + b.height);\n  return {x: xmin, y: ymin, width: xmax - xmin, height: ymax - ymin};\n};\n\nexport const ASSET_NODE_WIDTH = 320;\nexport const ASSET_NODE_TAGS_HEIGHT = 28;\nexport const ASSET_NODE_STATUS_ROW_HEIGHT = 25;\n\nexport const ASSET_NODE_NAME_MAX_LENGTH = 31;\n\nexport const getAssetNodeDimensions = (def: {\n  assetKey: {path: string[]};\n  opNames: string[];\n  isMaterializable: boolean;\n  isObservable: boolean;\n  isPartitioned: boolean;\n  graphName: string | null;\n  description?: string | null;\n  computeKind: string | null;\n  changedReasons?: ChangeReason[];\n}) => {\n  let height = 0;\n\n  height += ASSET_NODE_TAGS_HEIGHT; // top tags\n\n  height += 76; // box padding + border + name + description\n\n  if (def.isPartitioned && def.isMaterializable) {\n    height += ASSET_NODE_STATUS_ROW_HEIGHT;\n  }\n\n  height += ASSET_NODE_STATUS_ROW_HEIGHT; // status row\n  height += ASSET_NODE_STATUS_ROW_HEIGHT; // checks row\n  height += ASSET_NODE_TAGS_HEIGHT; // bottom tags\n\n  return {width: ASSET_NODE_WIDTH, height};\n};\n\nexport const getAssetNodeDimensions2025 = (facets: Set<AssetNodeFacet>) => {\n  let height = 50; // box padding + border + name\n\n  height += ASSET_NODE_STATUS_ROW_HEIGHT * facets.size;\n\n  return {width: ASSET_NODE_WIDTH, height};\n};\n","export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport type {IBounds, IPoint} from './common';\nimport {titleOfIO} from '../app/titleOfIO';\n\nexport type OpLayoutEdgeSide = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type OpLayoutEdge = {\n  from: OpLayoutEdgeSide;\n  to: OpLayoutEdgeSide;\n};\n\nexport interface OpLayout {\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n\n  // Frames of specific components - These need to be computed during layout\n  // (rather than at render time) to position edges into inputs/outputs.\n  op: IBounds;\n  inputs: {[inputName: string]: OpLayoutIO};\n  outputs: {[outputName: string]: OpLayoutIO};\n}\n\nexport interface OpLayoutIO {\n  layout: IBounds;\n  label: boolean;\n  collapsed: string[];\n  port: IPoint;\n}\n\nexport type OpGraphLayout = {\n  width: number;\n  height: number;\n  parent: ParentOpLayout | null;\n  edges: OpLayoutEdge[];\n  nodes: {[opName: string]: OpLayout};\n};\n\ninterface ParentOpLayout extends Omit<OpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: IBounds;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport type LayoutOpGraphOptions = {\n  parentOp?: ILayoutOp;\n};\n\nexport function layoutOpGraph(pipelineOps: ILayoutOp[], opts: LayoutOpGraphOptions): OpGraphLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (opts.parentOp) {\n    parentIOPadding =\n      Math.max(opts.parentOp.inputs.length, opts.parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy, ranker: 'tight-tree'});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const edges: OpLayoutEdge[] = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.bounds.width,\n      height: layout.bounds.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          edges.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: OpLayout} = {};\n  const dagreNodes: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    dagreNodes[opName] = node;\n  });\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.entries(dagreNodes).forEach(([opName, node]) => {\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = edges.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn && points.length > 0) {\n      conn.from.point = points[0]!;\n      conn.to.point = points[points.length - 1]!;\n    }\n  });\n\n  const result: OpGraphLayout = {\n    edges,\n    nodes: ops,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (opts.parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, opts.parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: OpGraphLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: ParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    bounds: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.bounds.y + result.bounds.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      collapsed: [],\n      label: true,\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      collapsed: [],\n      label: true,\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): OpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for an op with\n  // input blocks, then the main block, then output blocks (arranged vertically).\n  //\n  // This code \"appends\" boxes vertically, advancing accY as it goes.\n  let accY = root.y;\n\n  const appendMiniIODots = <T extends ILayoutOp['inputs'][0] | ILayoutOp['outputs'][0]>(\n    ios: T[],\n    sortKey: (io: T) => string,\n    clusteringKey: (io: T) => string,\n  ) => {\n    // Sort both input and output boxes displayed on the graph alphabetically based on the input name.\n    // This means that if two ops are connected to each other multiple times, the lines do not cross.\n    const sorted = [...ios].sort((a, b) => sortKey(a).localeCompare(sortKey(b)));\n\n    let x = 0;\n    let last: OpLayoutIO;\n    let lastKey: string | null = null;\n    const layouts: {[name: string]: OpLayoutIO} = {};\n    const spacing = Math.min(IO_MINI_WIDTH, OP_WIDTH / (sorted.length + 1));\n\n    // Add \"port\" layouts, collapsing the dots if they are connected to the same opposing solid\n    // (eg: two inputs connected to the same upstream output) with a \"[O] + 2\" style.\n    sorted.forEach((io, _idx) => {\n      const key = clusteringKey(io);\n      if (key !== lastKey) {\n        lastKey = key;\n        last = {\n          port: {\n            x: root.x + x + PORT_INSET_X,\n            y: accY + PORT_INSET_Y,\n          },\n          collapsed: [],\n          label: false,\n          layout: {\n            x: root.x + x,\n            y: accY,\n            width: IO_MINI_WIDTH,\n            height: IO_HEIGHT,\n          },\n        };\n        layouts[io.definition.name] = last;\n        x += spacing;\n      } else {\n        if (last.collapsed.length === 0) {\n          x += 15;\n        }\n        last.collapsed.push(io.definition.name);\n      }\n    });\n\n    // Center the items on the op rather than left justifying them\n    const centeringAdjustment = (OP_WIDTH - (x - PORT_INSET_X + IO_MINI_WIDTH)) / 2;\n    Object.values(layouts).forEach((l) => {\n      l.layout.x += centeringAdjustment;\n      l.port.x += centeringAdjustment;\n    });\n\n    // Place the next box beneath the\n    accY += IO_HEIGHT;\n\n    return layouts;\n  };\n\n  const appendStackedIOBoxes = (ios: ILayoutOp['inputs'] | ILayoutOp['outputs']) => {\n    const layouts: {[name: string]: OpLayoutIO} = {};\n    ios.forEach((io) => {\n      layouts[io.definition.name] = {\n        port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n        label: true,\n        collapsed: [],\n        layout: {\n          x: root.x,\n          y: accY,\n          width: 0,\n          height: IO_HEIGHT,\n        },\n      };\n      accY += IO_HEIGHT;\n    });\n    return layouts;\n  };\n\n  const inputLayouts =\n    op.inputs.length > IO_THRESHOLD_FOR_MINI\n      ? appendMiniIODots(\n          op.inputs,\n          (input) => input.definition.name,\n          (input) => input.dependsOn[0]?.solid.name || '',\n        )\n      : appendStackedIOBoxes(op.inputs);\n\n  const opLayout: IBounds = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts =\n    op.outputs.length > IO_THRESHOLD_FOR_MINI\n      ? appendMiniIODots(\n          op.outputs,\n          (o) => o.dependedBy[0]?.definition.name || '',\n          (o) => o.dependedBy[0]?.solid.name || '',\n        )\n      : appendStackedIOBoxes(op.outputs);\n\n  return {\n    bounds: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputLayouts,\n    outputs: outputLayouts,\n  };\n}\n","/* eslint-disable no-restricted-globals */\n\nimport {createWorkerThread} from 'shared/workers/WorkerThread.oss';\n\nimport {layoutAssetGraph} from '../asset-graph/layout';\nimport {layoutOpGraph} from '../graph/layout';\n/**\n * NOTE: Please avoid adding React as a transitive dependency to this file, as it can break\n * the development workflow. https://github.com/pmmmwh/react-refresh-webpack-plugin/issues/24\n *\n * If you see an error like `$RefreshReg$ is not defined` during development, check the\n * dependencies of this file. If you find that React has been included as a dependency, please\n * try to remove it.\n */\n\ncreateWorkerThread(\n  async (postMessage: (message: any) => void, data: any) => {\n    switch (data.type) {\n      case 'layoutOpGraph': {\n        const {ops, opts} = data;\n        postMessage(layoutOpGraph(ops, opts));\n        break;\n      }\n      case 'layoutAssetGraph': {\n        const {graphData, opts} = data;\n        postMessage(layoutAssetGraph(graphData, opts));\n      }\n    }\n  },\n  (_postMessage: (message: any) => void, error: Error) => {\n    console.error(error);\n  },\n);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [9774,5702,6506], function() { return __webpack_require__(90076); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames not based on template\n\tif (chunkId === 9774) return \"static/chunks/framework-b0b93c41d6f05eda.js\";\n\t// return url for filenames based on template\n\treturn \"static/chunks/\" + chunkId + \".\" + {\"5702\":\"d149ef3db8975756\",\"6506\":\"27211212f9b1f956\"}[chunkId] + \".js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var policy;\n__webpack_require__.tt = function() {\n\t// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.\n\tif (policy === undefined) {\n\t\tpolicy = {\n\t\t\tcreateScriptURL: function(url) { return url; }\n\t\t};\n\t\tif (typeof trustedTypes !== \"undefined\" && trustedTypes.createPolicy) {\n\t\t\tpolicy = trustedTypes.createPolicy(\"nextjs#bundler\", policy);\n\t\t}\n\t}\n\treturn policy;\n};","__webpack_require__.tu = function(url) { return __webpack_require__.tt().createScriptURL(url); };","__webpack_require__.p = \"BUILDTIME_ASSETPREFIX_REPLACE_ME/_next/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t76: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.u(chunkId)));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([9774,5702,6506].map(__webpack_require__.e, __webpack_require__)).then(next);\n};",null,"// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","policy","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","next","MapCache","__webpack_require__","memoize","func","resolver","memoized","args","arguments","key","apply","cache","has","get","result","set","Cache","module","exports","FeatureFlag","flagAssetSelectionWorker","flagSelectionSyntax","__TestFlagDefaultTrue","__TestFlagDefaultFalse","DAGSTER_FLAGS_KEY","WEB_WORKER_FEATURE_FLAGS_KEY","setFeatureFlagsInternal","flags","Array","isArray","localStorage","setItem","JSON","stringify","featureFlagsChannel","BroadcastChannel","initializeFeatureFlags","getJSONForKey","stored","window","getItem","parse","migratedFlags","forEach","flag","setFeatureFlags","postMessage","AssetGraphViewType","onMessage","onError","_ref","source","target","x","y","prop_types_default","oneOfType","object","string","any","Intl","NumberFormat","locale","minimumFractionDigits","maximumFractionDigits","Collator","navigator","language","sensitivity","toGraphId","path","fromGraphId","graphId","__typename","pathHorizontalDiagonal","s","isGroupId","test","str","groupIdForNode","node","definition","repository","name","location","groupName","join","getUpstreamNodes","assetKey","graphData","currentUpstream","upstream","keys","map","flat","filter","index","arr","findIndex","key2","data","Config","horizontal","ranker","direction","marginx","marginy","ranksep","rankdir","edgesep","nodesep","nodeHeight","groupPaddingTop","groupPaddingBottom","groupRendering","clusterpaddingtop","vertical","layoutAssetGraph","opts","layoutAssetGraphImpl","overrides","g","dagre","Graph","compound","config","Object","assign","facets","Set","setGraph","setDefaultEdgeLabel","shouldRender","renderedNodes","values","nodes","expandedGroupsSet","expandedGroups","groups","id","expanded","repositoryName","repositoryLocationName","bounds","width","height","groupsPresent","length","groupId","setNode","borderType","ASSET_NODE_WIDTH","label","getAssetNodeDimensions2025","getAssetNodeDimensions","setParent","linksToAssetsOutsideGraphedSet","groupIdForAssetId","fromEntries","entries","param","downstream","upstreamId","graphDataDownstream","downstreamIds","downstreamId","v","w","wGroup","vGroup","setEdge","weight","getAssetLinkDimensions","maxWidth","maxHeight","dagreNode","group","Math","max","nodeLayout","extendBounds","padBounds","top","bottom","edges","e","vXInset","wXInset","push","from","fromId","to","toId","min","a","padding","b","xmin","ymin","xmax","ymax","def","isPartitioned","isMaterializable","ASSET_NODE_STATUS_ROW_HEIGHT","size","titleOfIO","i","solid","concat","flattenIO","arrays","array","item","layoutExternalConnections","links","layoutWidth","insetWidth","inset","spacing","baseX","yShift","link","idx","layoutOp","op","root","accY","appendMiniIODots","ios","sortKey","clusteringKey","last","sorted","sort","localeCompare","lastKey","layouts","OP_WIDTH","io","_idx","port","IO_HEIGHT","collapsed","layout","centeringAdjustment","IO_MINI_WIDTH","l","appendStackedIOBoxes","inputLayouts","inputs","input","dependsOn","opLayout","OP_BASE_HEIGHT","assetNodes","description","outputLayouts","outputs","o","dependedBy","type","ops","layoutOpGraph","pipelineOps","parentIOPadding","parentOp","PARENT_DEFINITION_PADDING","PARENT_INVOCATION_PADDING","opNamesPresent","dep","point","opName","edgeName","dagreNodes","find","conn","c","points","edge","parent","layoutParentGraphOp","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","d","boundingBottom","output","_postMessage","error","console","self","addEventListener","event","Error","message","stack","String","undefined","__webpack_module_cache__","moduleId","cachedModule","loaded","threw","__webpack_modules__","m","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","r","n","getter","__esModule","defineProperty","enumerable","f","chunkId","Promise","all","reduce","promises","u","miniCssF","globalThis","obj","prop","prototype","hasOwnProperty","call","nmd","paths","children","tt","createScriptURL","url","trustedTypes","createPolicy","tu","p","importScripts","bind","moreModules","runtime","pop","then"],"sourceRoot":""}